
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
import { n as noop, k as dispatch_dev, v as validate_slots, l as SvelteComponentDev, o as init, p as safe_not_equal, e as element, c as create_component, a as attr_dev, b as add_location, i as insert_dev, d as append_dev, m as mount_component, f as transition_in, g as transition_out, h as detach_dev, j as destroy_component, F as Fragment } from './index-95874a9a.js';

/* src\ui\components\Sidebar.svelte generated by Svelte v3.38.2 */

const file$1 = "src\\ui\\components\\Sidebar.svelte";

function create_fragment$1(ctx) {
	const block = {
		c: noop,
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Sidebar", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Sidebar> was created with unknown prop '${key}'`);
	});

	return [];
}

class Sidebar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sidebar",
			options,
			id: create_fragment$1.name
		});
	}
}

var undefined$1 = undefined;

/* src\ui\routes\DashboardRoute.svelte generated by Svelte v3.38.2 */
const file = "src\\ui\\routes\\DashboardRoute.svelte";

// (5:0) <Fragment   isPadded={false}   isInAnimated={true}   isOutAnimated={true}   height='100vh'   width='100%'   justify='center'  >
function create_default_slot(ctx) {
	let component;
	let container;
	let sidebar;
	let current;
	sidebar = new Sidebar({ $$inline: true });

	const block = {
		c: function create() {
			component = element("component");
			container = element("container");
			create_component(sidebar.$$.fragment);
			attr_dev(container, "class", "sidebar svelte-14bkwas");
			add_location(container, file, 13, 2, 280);
			attr_dev(component, "class", "svelte-14bkwas");
			add_location(component, file, 12, 1, 265);
		},
		m: function mount(target, anchor) {
			insert_dev(target, component, anchor);
			append_dev(component, container);
			mount_component(sidebar, container, null);
			current = true;
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sidebar.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(sidebar.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(component);
			destroy_component(sidebar);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(5:0) <Fragment   isPadded={false}   isInAnimated={true}   isOutAnimated={true}   height='100vh'   width='100%'   justify='center'  >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let fragment;
	let current;

	fragment = new Fragment({
			props: {
				isPadded: false,
				isInAnimated: true,
				isOutAnimated: true,
				height: "100vh",
				width: "100%",
				justify: "center",
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(fragment.$$.fragment);
		},
		l: function claim(nodes) {
			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
		},
		m: function mount(target, anchor) {
			mount_component(fragment, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const fragment_changes = {};

			if (dirty & /*$$scope*/ 1) {
				fragment_changes.$$scope = { dirty, ctx };
			}

			fragment.$set(fragment_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(fragment.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(fragment.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(fragment, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("DashboardRoute", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DashboardRoute> was created with unknown prop '${key}'`);
	});

	$$self.$capture_state = () => ({ Fragment, Sidebar });
	return [];
}

class DashboardRoute extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DashboardRoute",
			options,
			id: create_fragment.name
		});
	}
}

export default DashboardRoute;
//# sourceMappingURL=DashboardRoute-f6e33124.js.map
